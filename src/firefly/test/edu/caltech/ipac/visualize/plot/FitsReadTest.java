package edu.caltech.ipac.visualize.plot;

import edu.caltech.ipac.table.io.FITSTableReader;
import edu.caltech.ipac.firefly.ConfigTest;
import edu.caltech.ipac.firefly.util.FileLoader;
import edu.caltech.ipac.firefly.util.FitsValidation;
import edu.caltech.ipac.table.DataGroup;
import edu.caltech.ipac.table.DataObject;
import nom.tam.fits.*;
import org.junit.After;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.zip.DataFormatException;

/**
 * Created by zhang on 12/9/16.
 * The input FITS file has three extension.  The expectedFits is created by reading the first extension using FitsRead
 * and saved to a new FITS file.  If the FitsRead is changed in the future, the test checks the newly created FitsRead
 * to see if it is the same as the saved one in expectedFIts.
 *
 * The tests also check
 *   if it reads the extension correct
 *   if the flux calculated correctly
 *   if the projection is correct
 *   if the FitsRead rotated correctly
 *
 *   5/24/18
 *   Unit test cases added for wavelength calculation in FitsRead
 *   The result FITS files are generated using the same input FITS file in the main program of FitsRead.
 *   The result file's name converstion is "waveLength"+algorthm+".fits", for example, if the algorithm is
 *   Linear, the name will be waveLengthLinear.fits.  The input FITS will be testLinear.fits.  Both testing
 *   and result FITS files are located in Firefly_test_data under the same package structures.
 *
 *
 */
public class FitsReadTest extends FitsValidation {
    private Fits threeExtensionFits; //it has more than one extension
    private String threeExtensionFileName = "HSC-0908120-056-small.fits";
    private Fits inFits; //it has more than one extension
    private Fits inCubeFits;
    private String  inCubeFitsFileName = "cube1.fits";
    private String expectedCubeFitsFileName = "cube1_out.fits";
    private Fits expectedOutCubeFits;
    private Fits expectedFits; //the FITS only has one FitsRead
    private Fits expectedRAFromNorthup;
    private Fits expectedRANotFromNorthup;
    private String inFitsFileName ="f3.fits";
    private static String expectedFitsFileName = "f3_out.fits";
    private double expectedFlux = 3.1980953037272997E7;
    private int expectedProjection=1001;
    private  double  delta =0.1e-10;
    private String expectedRAFromNorthFileName ="f3_rotationFromNorth_out.fits";
    private String expectedRANotFromNorthFileName ="f3_rotationNotFromNorth_out.fits";

    private  FitsRead  fitsRead0;

    @Before
    /**
     * An one dimensional array is created and it is used to run the unit test for Histogram's public methods
     */
    public void setUp() throws FitsException, ClassNotFoundException, IOException {
        //this FITS file has three extensions.  Using it as expected value to get if the FitsRead can get all extensions
        threeExtensionFits = FileLoader.loadFits(FitsReadTest.class, threeExtensionFileName);

        /*
        The inFits has only one extension.
        the expectedFits is generated by using inFits as an input which was read in by FitsRead and then writes the
        result out to an output FITS file.
        This file is served as an expected result.  If the FitsRead is changed in the future, it should produce the same
        results as expectedFits.  If it does not, the bug is introduced.
         */
        inFits = FileLoader.loadFits(FitsReadTest.class, inFitsFileName);
        expectedFits = FileLoader.loadFits(FitsReadTest.class, expectedFitsFileName);

        /*
         The following two files are used to testing FitsRead's rotation method.
         */
        expectedRAFromNorthup = FileLoader.loadFits(FitsReadTest.class, expectedRAFromNorthFileName);
        expectedRANotFromNorthup = FileLoader.loadFits(FitsReadTest.class, expectedRANotFromNorthFileName);

        /*
        This following two FITS files are used to test ImageCube.
         */
        inCubeFits =  FileLoader.loadFits(FitsReadTest.class, inCubeFitsFileName);
        expectedOutCubeFits = FileLoader.loadFits(FitsReadTest.class, expectedCubeFitsFileName);

        //Create an instance of FitsRead here
        fitsRead0 = FitsRead.createFitsReadArray(inFits)[0];

    }
    @After
    /**
     * Release the memories
     */
    public void tearDown() {
        threeExtensionFits =null;
        inFits=null;
        expectedFits=null;
        expectedRAFromNorthup=null;
        expectedRANotFromNorthup=null;

        ConfigTest.LOG.info("FitsRead test is done, the memory is released now");

    }

    @Test
    public void testProjection() throws FitsException{
        Assert.assertEquals(fitsRead0.getProjectionType(), expectedProjection);
        ConfigTest.LOG.info("test projection is pass");
    }
    @Test
    public void testGetFlux() throws PixelValueException,FitsException {
        ImagePt imagePt = new ImagePt(325.5482500, 66.0750000);
        Assert.assertEquals(fitsRead0.getFlux(imagePt), expectedFlux, delta);
    }
    @Test
    public void testFitsReadArrayCount() throws FitsException {
        FitsRead[]  fitsReadArray= FitsRead.createFitsReadArray(threeExtensionFits);
        Assert.assertEquals(fitsReadArray.length, 3);
    }
    @Test
    public void testFitsRead() throws FitsException, IOException {

        Fits  newFits = fitsRead0.createNewFits();
        validateFits(expectedFits, newFits);
    }


    @Test
    public void testCreateFitsReadRotatedAngle() throws FitsException, IOException, GeomException {
         double angle = 30;
         FitsRead raFromNorthUp = FitsRead.createFitsReadRotated(fitsRead0, angle, true);
         validateFits(expectedRAFromNorthup, raFromNorthUp.createNewFits() );
         FitsRead raNotFromNorthUp = FitsRead.createFitsReadRotated(fitsRead0, angle, false);
         validateFits(expectedRANotFromNorthup, raNotFromNorthUp.createNewFits() );
    }

    @Test
    public void testCreateFitsImageCube() throws FitsException, IOException {

        FitsImageCube fic = FitsRead.createFitsImageCube(inCubeFits);
        Object[] keys = fic.getMapKeys();
        FitsRead calFitsRead0 = fic.getFitsReadMap().get(keys[0])[1];
        Fits  newFits = calFitsRead0.createNewFits();
        validateFits(expectedOutCubeFits, newFits);

    }

    private DataGroup loadResultTable(String algorithm) throws FitsException, IOException {
        String retFitsName = "waveLength"+algorithm+".fits";
        String inFitsName = FileLoader.getDataPath(FitsReadTest.class) + retFitsName;
        String[] dataCols = {"WaveLength"};
        DataGroup table = FITSTableReader.convertFitsToDataGroup(
                inFitsName,
                dataCols,
                null,
                FITSTableReader.EXPAND_BEST_FIT, 1);
        return table;
    }

    private void validateWaveLengthResult(String algorithm, ArrayList<Double> ret ) throws FitsException, IOException, DataFormatException, PixelValueException {

        double[] cResult = new double[ret.size()];
        for (int i=0; i<ret.size(); i++){
            cResult[i]=ret.get(i).doubleValue();
        }

        //load the expected results (the expected results were generated in FitsRead and saved to the FITS file
        DataGroup table = loadResultTable(algorithm);
        List<DataObject> list =  table.values();
        double[] exResult = new double[list.size()];
        for (int i=0; i<list.size(); i++){
            exResult[i]= ( (Double) list.get(i).getDataElement("WaveLength")).doubleValue();
        }
        Assert.assertArrayEquals(exResult, cResult, delta);

    }

    private ArrayList<Double> calculateExpectedResult(Fits fits, FitsRead[] frArray)throws FitsException, IOException, DataFormatException, PixelValueException{

        BasicHDU primaryHdu = fits.getHDU(0);
        int naxis1 = primaryHdu.getHeader().getIntValue("NAXIS1");
        int naxis2 = primaryHdu.getHeader().getIntValue("NAXIS2");
        ArrayList<Double> cResult = new ArrayList<>();

        ImagePt imagePt;
        for (int i = 0; i < naxis1; i++) {
            for (int j = 0; j < naxis2; j++) {
                imagePt = new ImagePt(i, j);
                cResult.add(frArray[0].getWaveLength(imagePt));
            }

        }
        return cResult;
    }

    /**
     * This is a unit test to test wavelength calculation using Table Lookup
     * @throws FitsException
     * @throws IOException
     * @throws DataFormatException
     * @throws PixelValueException
     */
    @Test
    public void testGetWaveLengthTable()throws FitsException, IOException, DataFormatException, PixelValueException {

        String inFitsName = "testTable.fits";
        Fits fits = FileLoader.loadFits(FitsReadTest.class, inFitsName);
        FitsRead[] frArray = FitsRead.createFitsReadArray(fits);
        ArrayList<Double> cResult = calculateExpectedResult(fits,frArray );
        validateWaveLengthResult("Table", cResult);

    }

    private void testGetWaveLengthWCSKeyWord(String algorithm)throws FitsException, IOException, DataFormatException, PixelValueException {

        String inFitsName = "test"+algorithm+".fits";
        Fits fits = FileLoader.loadFits(FitsReadTest.class, inFitsName);
        FitsRead[] frArray = FitsRead.createFitsReadArray(fits);
        ArrayList<Double> cResult = calculateExpectedResult(fits,frArray );
        validateWaveLengthResult(algorithm, cResult);
    }

    /**
     * This is a unit test to test wavelength calculations using Liner, Log and Non-linear algorithm
     * @throws DataFormatException
     * @throws FitsException
     * @throws PixelValueException
     * @throws IOException
     */
    @Test
    public void testGetWaveLength() throws DataFormatException, FitsException, PixelValueException, IOException {

        //Test Linear, Log and Nonlinear (F2W, V2W)
        String[] algorithms = {"Linear", "Log", "F2W", "V2W"};
        for (int i=0; i<algorithms.length; i++){
            testGetWaveLengthWCSKeyWord(algorithms[i]);
        }

    }


    @Test
    public void testCreateFitsReadRotatedFromNorth(){
       //TODO
    }


    @Test
    public void testEndToEndFitsReadCreateFlipLR(){
      //TODO
    }
    @Test
    public void testEndToEndCreateFitsReadNorthUp(){
       //TODO
    }
    @Test
    public void testEndToEndCreateFitsReadNorthUpGalactic(){
      //TODO
    }

    @Test
    public void testEndToEndCreateFitsReadWithGeom(){
     //TODO
    }

    public static void main (String[] args) throws FitsException, IOException, ClassNotFoundException, PixelValueException, GeomException {

        //prepare  the expected results for end to end  tests

        String dataPath = FileLoader.getDataPath( FitsReadTest.class);
        String fileName="f3.fits";
        String outFitsName=dataPath+"/f3_out.fits";
        Fits  inFits = FileLoader.loadFits(FitsReadTest.class, fileName);
        FitsRead fitsRead0 = FitsRead.createFitsReadArray(inFits)[0];
        FileOutputStream fo = new java.io.FileOutputStream(outFitsName);
        fitsRead0.writeSimpleFitsFile(fo);
        fo.close();

        ImagePt imagePt = new ImagePt(325.5482500, 66.0750000);
        double flux = fitsRead0.getFlux(imagePt);
        System.out.println("flux="+flux+ " the projection="+fitsRead0.getProjectionType());

        double angle = 30;
        String rotationFitsName=dataPath+"/f3_rotationFromNorth_out.fits";
        FitsRead frRotaionAnglefromNorth = FitsRead.createFitsReadRotated(fitsRead0,angle, true);

        fo = new java.io.FileOutputStream(rotationFitsName);
        frRotaionAnglefromNorth.writeSimpleFitsFile(fo);
        fo.close();

        String rotation1FitsName=dataPath+"/f3_rotationNotFromNorth_out.fits";
        FitsRead frRotaionAngleNotfromNorth = FitsRead.createFitsReadRotated(fitsRead0,angle, false);
        fo = new java.io.FileOutputStream(rotation1FitsName);
        frRotaionAngleNotfromNorth.writeSimpleFitsFile(fo);
        fo.close();

        String cubeFitsName="cube1.fits";
        String outCubeFitsName=dataPath+"/cube1_out.fits";
        Fits  inCubeFits = FileLoader.loadFits(FitsReadTest.class, cubeFitsName);
        FitsImageCube fic = FitsRead.createFitsImageCube(inCubeFits);
        Object[] keys = fic.getMapKeys();
        FitsRead cubeFitsRead0 = fic.getFitsReadMap().get(keys[0])[1];
         fo = new java.io.FileOutputStream( outCubeFitsName);
        cubeFitsRead0.writeSimpleFitsFile(fo);
        fo.close();

    }

}
