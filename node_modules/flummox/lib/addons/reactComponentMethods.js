"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

/**
 * React Component methods. These are the primitives used to implement
 * fluxMixin and FluxComponent.
 *
 * Exposes a Flux instance as `this.flux`. This requires that flux be passed as
 * either context or as a prop (prop takes precedence). Children also are given
 * access to flux instance as `context.flux`.
 *
 * It also adds the method `connectToStores()`, which ensures that the component
 * state stays in sync with the specified Flux stores. See the inline docs
 * of `connectToStores` for details.
 */

var _react = require("react");

var React = _interopRequire(_react);

var PropTypes = _react.PropTypes;
var Flux = require("../Flux").Flux;
var assign = _interopRequire(require("object-assign"));

var instanceMethods = {

  getChildContext: function getChildContext() {
    var flux = this.getFlux();

    if (!flux) {
      return {};
    }return {
      flux: this.getFlux()
    };
  },

  getFlux: function getFlux() {
    return this.props.flux || this.context.flux;
  },

  initialize: function initialize() {
    this._fluxStateGetters = [];
    this._fluxListeners = {};
    this._fluxDidSyncStoreState = false;
    this.flux = this.getFlux();

    if (!(this.flux instanceof Flux)) {
      // TODO: print the actual class name here
      throw new Error("fluxMixin: Could not find Flux instance. Ensure that your component " + "has either `this.context.flux` or `this.props.flux`.");
    }
  },

  componentWillUnmount: function componentWillUnmount() {
    var flux = this.getFlux();

    for (var key in this._fluxListeners) {
      if (!this._fluxListeners.hasOwnProperty(key)) continue;

      var store = flux.getStore(key);
      if (typeof store === "undefined") continue;

      var listener = this._fluxListeners[key];

      store.removeListener("change", listener);
    }
  },

  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    this.updateStores(nextProps);
  },

  updateStores: function updateStores() {
    var props = arguments[0] === undefined ? this.props : arguments[0];
    var state = this.getStoreState(props);
    this.setState(state);
  },

  getStoreState: function getStoreState() {
    var props = arguments[0] === undefined ? this.props : arguments[0];
    return this._fluxStateGetters.reduce(function (result, stateGetter) {
      var getter = stateGetter.getter;
      var stores = stateGetter.stores;
      var stateFromStores = getter(stores, props);
      return assign(result, stateFromStores);
    }, {});
  },

  /**
   * Connect component to stores, get the combined initial state, and
   * subscribe to future changes. There are three ways to call it. The
   * simplest is to pass a single store key and, optionally, a state getter.
   * The state getter is a function that takes the store as a parameter and
   * returns the state that should be passed to the component's `setState()`.
   * If no state getter is specified, the default getter is used, which simply
   * returns the entire store state.
   *
   * The second form accepts an array of store keys. With this form, the state
   * getter is called once with an array of store instances (in the same order
   * as the store keys). the default getter performance a reduce on the entire
   * state for each store.
   *
   * The last form accepts an object of store keys mapped to state getters. As
   * a shortcut, you can pass `null` as a state getter to use the default
   * state getter.
   *
   * Returns the combined initial state of all specified stores.
   *
   * This way you can write all the initialization and update logic in a single
   * location, without having to mess with adding/removing listeners.
   *
   * @type {string|array|object} stateGetterMap - map of keys to getters
   * @returns {object} Combined initial state of stores
   */
  connectToStores: function connectToStores() {
    var _this = this;
    var stateGetterMap = arguments[0] === undefined ? {} : arguments[0];
    var stateGetter = arguments[1] === undefined ? null : arguments[1];
    var flux = this.getFlux();

    var getStore = function (key) {
      var store = flux.getStore(key);

      if (typeof store === "undefined") {
        throw new Error("connectToStores(): Store with key '" + key + "' does not exist.");
      }

      return store;
    };

    if (typeof stateGetterMap === "string") {
      var key = stateGetterMap;
      var store = getStore(key);
      var getter = stateGetter || defaultStateGetter;

      this._fluxStateGetters.push({ stores: store, getter: getter });
      var listener = createStoreListener(this, store, getter);

      store.addListener("change", listener);
      this._fluxListeners[key] = listener;
    } else if (Array.isArray(stateGetterMap)) {
      (function () {
        var stores = stateGetterMap.map(getStore);
        var getter = stateGetter || defaultReduceStateGetter;

        _this._fluxStateGetters.push({ stores: stores, getter: getter });
        var listener = createStoreListener(_this, stores, getter);

        stateGetterMap.forEach(function (key, index) {
          var store = stores[index];
          store.addListener("change", listener);
          _this._fluxListeners[key] = listener;
        });
      })();
    } else {
      for (var key in stateGetterMap) {
        var store = getStore(key);
        var getter = stateGetterMap[key] || defaultStateGetter;

        this._fluxStateGetters.push({ stores: store, getter: getter });
        var listener = createStoreListener(this, store, getter);

        store.addListener("change", listener);
        this._fluxListeners[key] = listener;
      }
    }

    return this.getStoreState();
  }

};

var staticProperties = {
  contextTypes: {
    flux: PropTypes.instanceOf(Flux) },

  childContextTypes: {
    flux: PropTypes.instanceOf(Flux) },

  propTypes: {
    connectToStores: React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.arrayOf(React.PropTypes.string), React.PropTypes.func])
  } };

exports.instanceMethods = instanceMethods;
exports.staticProperties = staticProperties;


function createStoreListener(component, store, storeStateGetter) {
  return (function () {
    var state = storeStateGetter(store, this.props);
    this.setState(state);
  }).bind(component);
}

function defaultStateGetter(store) {
  return store.state;
}

function defaultReduceStateGetter(stores) {
  return stores.reduce(function (result, store) {
    return assign(result, store.state);
  }, {});
}
Object.defineProperty(exports, "__esModule", {
  value: true
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hZGRvbnMvcmVhY3RDb21wb25lbnRNZXRob2RzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O3FCQWE0QyxPQUFPOztJQUEvQixLQUFLOztJQUFFLFNBQVMsVUFBVCxTQUFTO0lBQzNCLElBQUksV0FBUSxTQUFTLEVBQXJCLElBQUk7SUFDTixNQUFNLDJCQUFNLGVBQWU7O0FBRWxDLElBQU0sZUFBZSxHQUFHOztBQUV0QixpQkFBZSxFQUFBLDJCQUFHO0FBQ2hCLFFBQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQzs7QUFFNUIsUUFBSSxDQUFDLElBQUk7QUFBRSxhQUFPLEVBQUUsQ0FBQztLQUFBLEFBRXJCLE9BQU87QUFDTCxVQUFJLEVBQUUsSUFBSSxDQUFDLE9BQU8sRUFBRTtLQUNyQixDQUFDO0dBQ0g7O0FBRUQsU0FBTyxFQUFBLG1CQUFHO0FBQ1IsV0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQztHQUM3Qzs7QUFFRCxZQUFVLEVBQUEsc0JBQUc7QUFDWCxRQUFJLENBQUMsaUJBQWlCLEdBQUcsRUFBRSxDQUFDO0FBQzVCLFFBQUksQ0FBQyxjQUFjLEdBQUcsRUFBRSxDQUFDO0FBQ3pCLFFBQUksQ0FBQyxzQkFBc0IsR0FBRyxLQUFLLENBQUM7QUFDcEMsUUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7O0FBRTNCLFFBQUksRUFBRSxJQUFJLENBQUMsSUFBSSxZQUFZLElBQUksQ0FBQSxBQUFDLEVBQUU7O0FBRWhDLFlBQU0sSUFBSSxLQUFLLENBQ2IsK0hBQzBELENBQzNELENBQUM7S0FDSDtHQUNGOztBQUVELHNCQUFvQixFQUFBLGdDQUFHO0FBQ3JCLFFBQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQzs7QUFFNUIsU0FBSyxJQUFJLEdBQUcsSUFBSSxJ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QUksQ0FBQyxFQUNqQzs7QUFFRCxtQkFBaUIsRUFBRTtBQUNqQixRQUFJLEVBQUUsU0FBUyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsRUFDakM7O0FBRUQsV0FBUyxFQUFFO0FBQ1QsbUJBQWUsRUFBRSxLQUFLLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxDQUN6QyxLQUFLLENBQUMsU0FBUyxDQUFDLE1BQU0sRUFDdEIsS0FBSyxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsRUFDL0MsS0FBSyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQ3JCLENBQUM7R0FDSCxFQUNGLENBQUM7O1FBRU8sZUFBZSxHQUFmLGVBQWU7UUFBRSxnQkFBZ0IsR0FBaEIsZ0JBQWdCOzs7QUFFMUMsU0FBUyxtQkFBbUIsQ0FBQyxTQUFTLEVBQUUsS0FBSyxFQUFFLGdCQUFnQixFQUFFO0FBQy9ELFNBQU8sQ0FBQSxZQUFXO0FBQ2hCLFFBQU0sS0FBSyxHQUFHLGdCQUFnQixDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDbEQsUUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztHQUN0QixDQUFBLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0NBQ25COztBQUVELFNBQVMsa0JBQWtCLENBQUMsS0FBSyxFQUFFO0FBQ2pDLFNBQU8sS0FBSyxDQUFDLEtBQUssQ0FBQztDQUNwQjs7QUFFRCxTQUFTLHdCQUF3QixDQUFDLE1BQU0sRUFBRTtBQUN4QyxTQUFPLE1BQU0sQ0FBQyxNQUFNLENBQ2xCLFVBQUMsTUFBTSxFQUFFLEtBQUs7V0FBSyxNQUFNLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxLQUFLLENBQUM7R0FBQSxFQUM5QyxFQUFFLENBQ0gsQ0FBQztDQUNIIiwiZmlsZSI6InNyYy9hZGRvbnMvcmVhY3RDb21wb25lbnRNZXRob2RzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBSZWFjdCBDb21wb25lbnQgbWV0aG9kcy4gVGhlc2UgYXJlIHRoZSBwcmltaXRpdmVzIHVzZWQgdG8gaW1wbGVtZW50XG4gKiBmbHV4TWl4aW4gYW5kIEZsdXhDb21wb25lbnQuXG4gKlxuICogRXhwb3NlcyBhIEZsdXggaW5zdGFuY2UgYXMgYHRoaXMuZmx1eGAuIFRoaXMgcmVxdWlyZXMgdGhhdCBmbHV4IGJlIHBhc3NlZCBhc1xuICogZWl0aGVyIGNvbnRleHQgb3IgYXMgYSBwcm9wIChwcm9wIHRha2VzIHByZWNlZGVuY2UpLiBDaGlsZHJlbiBhbHNvIGFyZSBnaXZlblxuICogYWNjZXNzIHRvIGZsdXggaW5zdGFuY2UgYXMgYGNvbnRleHQuZmx1eGAuXG4gKlxuICogSXQgYWxzbyBhZGRzIHRoZSBtZXRob2QgYGNvbm5lY3RUb1N0b3JlcygpYCwgd2hpY2ggZW5zdXJlcyB0aGF0IHRoZSBjb21wb25lbnRcbiAqIHN0YXRlIHN0YXlzIGluIHN5bmMgd2l0aCB0aGUgc3BlY2lmaWVkIEZsdXggc3RvcmVzLiBTZWUgdGhlIGlubGluZSBkb2NzXG4gKiBvZiBgY29ubmVjdFRvU3RvcmVzYCBmb3IgZGV0YWlscy5cbiAqL1xuXG5pbXBvcnQgeyBkZWZhdWx0IGFzIFJlYWN0LCBQcm9wVHlwZXMgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBGbHV4IH0gZnJvbSAnLi4vRmx1eCc7XG5pbXBvcnQgYXNzaWduIGZyb20gJ29iamVjdC1hc3NpZ24nO1xuXG5jb25zdCBpbnN0YW5jZU1ldGhvZHMgPSB7XG5cbiAgZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgIGNvbnN0IGZsdXggPSB0aGlzLmdldEZsdXgoKTtcblxuICAgIGlmICghZmx1eCkgcmV0dXJuIHt9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGZsdXg6IHRoaXMuZ2V0Rmx1eCgpXG4gICAgfTtcbiAgfSxcblxuICBnZXRGbHV4KCkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLmZsdXggfHwgdGhpcy5jb250ZXh0LmZsdXg7XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLl9mbHV4U3RhdGVHZXR0ZXJzID0gW107XG4gICAgdGhpcy5fZmx1eExpc3RlbmVycyA9IHt9O1xuICAgIHRoaXMuX2ZsdXhEaWRTeW5jU3RvcmVTdGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuZmx1eCA9IHRoaXMuZ2V0Rmx1eCgpO1xuXG4gICAgaWYgKCEodGhpcy5mbHV4IGluc3RhbmNlb2YgRmx1eCkpIHtcbiAgICAgIC8vIFRPRE86IHByaW50IHRoZSBhY3R1YWwgY2xhc3MgbmFtZSBoZXJlXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBmbHV4TWl4aW46IENvdWxkIG5vdCBmaW5kIEZsdXggaW5zdGFuY2UuIEVuc3VyZSB0aGF0IHlvdXIgY29tcG9uZW50IGBcbiAgICAgICsgYGhhcyBlaXRoZXIgXFxgdGhpcy5jb250ZXh0LmZsdXhcXGAgb3IgXFxgdGhpcy5wcm9wcy5mbHV4XFxgLmBcbiAgICAgICk7XG4gICAgfVxuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGNvbnN0IGZsdXggPSB0aGlzLmdldEZsdXgoKTtcblxuICAgIGZvciAobGV0IGtleSBpbiB0aGlzLl9mbHV4TGlzdGVuZXJzKSB7XG4gICAgICBpZiAoIXRoaXMuX2ZsdXhMaXN0ZW5lcnMuaGFzT3duUHJvcGVydHkoa2V5KSkgY29udGludWU7XG5cbiAgICAgIGNvbnN0IHN0b3JlID0gZmx1eC5nZXRTdG9yZShrZXkpO1xuICAgICAgaWYgKHR5cGVvZiBzdG9yZSA9PT0gJ3VuZGVmaW5lZCcpIGNvbnRpbnVlO1xuXG4gICAgICBjb25zdCBsaXN0ZW5lciA9IHRoaXMuX2ZsdXhMaXN0ZW5lcnNba2V5XTtcblxuICAgICAgc3RvcmUucmVtb3ZlTGlzdGVuZXIoJ2NoYW5nZScsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH0sXG5cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICB0aGlzLnVwZGF0ZVN0b3JlcyhuZXh0UHJvcHMpO1xuICB9LFxuXG4gIHVwZGF0ZVN0b3Jlcyhwcm9wcyA9IHRoaXMucHJvcHMpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0U3RvcmVTdGF0ZShwcm9wcyk7XG4gICAgdGhpcy5zZXRTdGF0ZShzdGF0ZSk7XG4gIH0sXG5cbiAgZ2V0U3RvcmVTdGF0ZShwcm9wcyA9IHRoaXMucHJvcHMpIHtcbiAgICByZXR1cm4gdGhpcy5fZmx1eFN0YXRlR2V0dGVycy5yZWR1Y2UoXG4gICAgICAocmVzdWx0LCBzdGF0ZUdldHRlcikgPT4ge1xuICAgICAgICBjb25zdCB7IGdldHRlciwgc3RvcmVzIH0gPSBzdGF0ZUdldHRlcjtcbiAgICAgICAgY29uc3Qgc3RhdGVGcm9tU3RvcmVzID0gZ2V0dGVyKHN0b3JlcywgcHJvcHMpO1xuICAgICAgICByZXR1cm4gYXNzaWduKHJlc3VsdCwgc3RhdGVGcm9tU3RvcmVzKTtcbiAgICAgIH0sIHt9XG4gICAgKTtcbiAgfSxcblxuICAgLyoqXG4gICAgKiBDb25uZWN0IGNvbXBvbmVudCB0byBzdG9yZXMsIGdldCB0aGUgY29tYmluZWQgaW5pdGlhbCBzdGF0ZSwgYW5kXG4gICAgKiBzdWJzY3JpYmUgdG8gZnV0dXJlIGNoYW5nZXMuIFRoZXJlIGFyZSB0aHJlZSB3YXlzIHRvIGNhbGwgaXQuIFRoZVxuICAgICogc2ltcGxlc3QgaXMgdG8gcGFzcyBhIHNpbmdsZSBzdG9yZSBrZXkgYW5kLCBvcHRpb25hbGx5LCBhIHN0YXRlIGdldHRlci5cbiAgICAqIFRoZSBzdGF0ZSBnZXR0ZXIgaXMgYSBmdW5jdGlvbiB0aGF0IHRha2VzIHRoZSBzdG9yZSBhcyBhIHBhcmFtZXRlciBhbmRcbiAgICAqIHJldHVybnMgdGhlIHN0YXRlIHRoYXQgc2hvdWxkIGJlIHBhc3NlZCB0byB0aGUgY29tcG9uZW50J3MgYHNldFN0YXRlKClgLlxuICAgICogSWYgbm8gc3RhdGUgZ2V0dGVyIGlzIHNwZWNpZmllZCwgdGhlIGRlZmF1bHQgZ2V0dGVyIGlzIHVzZWQsIHdoaWNoIHNpbXBseVxuICAgICogcmV0dXJucyB0aGUgZW50aXJlIHN0b3JlIHN0YXRlLlxuICAgICpcbiAgICAqIFRoZSBzZWNvbmQgZm9ybSBhY2NlcHRzIGFuIGFycmF5IG9mIHN0b3JlIGtleXMuIFdpdGggdGhpcyBmb3JtLCB0aGUgc3RhdGVcbiAgICAqIGdldHRlciBpcyBjYWxsZWQgb25jZSB3aXRoIGFuIGFycmF5IG9mIHN0b3JlIGluc3RhbmNlcyAoaW4gdGhlIHNhbWUgb3JkZXJcbiAgICAqIGFzIHRoZSBzdG9yZSBrZXlzKS4gdGhlIGRlZmF1bHQgZ2V0dGVyIHBlcmZvcm1hbmNlIGEgcmVkdWNlIG9uIHRoZSBlbnRpcmVcbiAgICAqIHN0YXRlIGZvciBlYWNoIHN0b3JlLlxuICAgICpcbiAgICAqIFRoZSBsYXN0IGZvcm0gYWNjZXB0cyBhbiBvYmplY3Qgb2Ygc3RvcmUga2V5cyBtYXBwZWQgdG8gc3RhdGUgZ2V0dGVycy4gQXNcbiAgICAqIGEgc2hvcnRjdXQsIHlvdSBjYW4gcGFzcyBgbnVsbGAgYXMgYSBzdGF0ZSBnZXR0ZXIgdG8gdXNlIHRoZSBkZWZhdWx0XG4gICAgKiBzdGF0ZSBnZXR0ZXIuXG4gICAgKlxuICAgICogUmV0dXJucyB0aGUgY29tYmluZWQgaW5pdGlhbCBzdGF0ZSBvZiBhbGwgc3BlY2lmaWVkIHN0b3Jlcy5cbiAgICAqXG4gICAgKiBUaGlzIHdheSB5b3UgY2FuIHdyaXRlIGFsbCB0aGUgaW5pdGlhbGl6YXRpb24gYW5kIHVwZGF0ZSBsb2dpYyBpbiBhIHNpbmdsZVxuICAgICogbG9jYXRpb24sIHdpdGhvdXQgaGF2aW5nIHRvIG1lc3Mgd2l0aCBhZGRpbmcvcmVtb3ZpbmcgbGlzdGVuZXJzLlxuICAgICpcbiAgICAqIEB0eXBlIHtzdHJpbmd8YXJyYXl8b2JqZWN0fSBzdGF0ZUdldHRlck1hcCAtIG1hcCBvZiBrZXlzIHRvIGdldHRlcnNcbiAgICAqIEByZXR1cm5zIHtvYmplY3R9IENvbWJpbmVkIGluaXRpYWwgc3RhdGUgb2Ygc3RvcmVzXG4gICAgKi9cbiAgY29ubmVjdFRvU3RvcmVzKHN0YXRlR2V0dGVyTWFwID0ge30sIHN0YXRlR2V0dGVyID0gbnVsbCkge1xuICAgIGNvbnN0IGZsdXggPSB0aGlzLmdldEZsdXgoKTtcblxuICAgIGNvbnN0IGdldFN0b3JlID0gKGtleSkgPT4ge1xuICAgICAgY29uc3Qgc3RvcmUgPSBmbHV4LmdldFN0b3JlKGtleSk7XG5cbiAgICAgIGlmICh0eXBlb2Ygc3RvcmUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgY29ubmVjdFRvU3RvcmVzKCk6IFN0b3JlIHdpdGgga2V5ICcke2tleX0nIGRvZXMgbm90IGV4aXN0LmBcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0b3JlO1xuICAgIH07XG5cbiAgICBpZiAodHlwZW9mIHN0YXRlR2V0dGVyTWFwID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3Qga2V5ID0gc3RhdGVHZXR0ZXJNYXA7XG4gICAgICBjb25zdCBzdG9yZSA9IGdldFN0b3JlKGtleSk7XG4gICAgICBjb25zdCBnZXR0ZXIgPSBzdGF0ZUdldHRlciB8fCBkZWZhdWx0U3RhdGVHZXR0ZXI7XG5cbiAgICAgIHRoaXMuX2ZsdXhTdGF0ZUdldHRlcnMucHVzaCh7IHN0b3Jlczogc3RvcmUsIGdldHRlciB9KTtcbiAgICAgIGNvbnN0IGxpc3RlbmVyID0gY3JlYXRlU3RvcmVMaXN0ZW5lcih0aGlzLCBzdG9yZSwgZ2V0dGVyKTtcblxuICAgICAgc3RvcmUuYWRkTGlzdGVuZXIoJ2NoYW5nZScsIGxpc3RlbmVyKTtcbiAgICAgIHRoaXMuX2ZsdXhMaXN0ZW5lcnNba2V5XSA9IGxpc3RlbmVyO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzdGF0ZUdldHRlck1hcCkpIHtcbiAgICAgIGNvbnN0IHN0b3JlcyA9IHN0YXRlR2V0dGVyTWFwLm1hcChnZXRTdG9yZSk7XG4gICAgICBjb25zdCBnZXR0ZXIgPSBzdGF0ZUdldHRlciB8fCBkZWZhdWx0UmVkdWNlU3RhdGVHZXR0ZXI7XG5cbiAgICAgIHRoaXMuX2ZsdXhTdGF0ZUdldHRlcnMucHVzaCh7IHN0b3JlcywgZ2V0dGVyIH0pO1xuICAgICAgY29uc3QgbGlzdGVuZXIgPSBjcmVhdGVTdG9yZUxpc3RlbmVyKHRoaXMsIHN0b3JlcywgZ2V0dGVyKTtcblxuICAgICAgc3RhdGVHZXR0ZXJNYXAuZm9yRWFjaCgoa2V5LCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBzdG9yZSA9IHN0b3Jlc1tpbmRleF07XG4gICAgICAgIHN0b3JlLmFkZExpc3RlbmVyKCdjaGFuZ2UnLCBsaXN0ZW5lcik7XG4gICAgICAgIHRoaXMuX2ZsdXhMaXN0ZW5lcnNba2V5XSA9IGxpc3RlbmVyO1xuICAgICAgfSk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgIGZvciAobGV0IGtleSBpbiBzdGF0ZUdldHRlck1hcCkge1xuICAgICAgICBjb25zdCBzdG9yZSA9IGdldFN0b3JlKGtleSk7XG4gICAgICAgIGNvbnN0IGdldHRlciA9IHN0YXRlR2V0dGVyTWFwW2tleV0gfHwgZGVmYXVsdFN0YXRlR2V0dGVyO1xuXG4gICAgICAgIHRoaXMuX2ZsdXhTdGF0ZUdldHRlcnMucHVzaCh7IHN0b3Jlczogc3RvcmUsIGdldHRlciB9KTtcbiAgICAgICAgY29uc3QgbGlzdGVuZXIgPSBjcmVhdGVTdG9yZUxpc3RlbmVyKHRoaXMsIHN0b3JlLCBnZXR0ZXIpO1xuXG4gICAgICAgIHN0b3JlLmFkZExpc3RlbmVyKCdjaGFuZ2UnLCBsaXN0ZW5lcik7XG4gICAgICAgIHRoaXMuX2ZsdXhMaXN0ZW5lcnNba2V5XSA9IGxpc3RlbmVyO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmdldFN0b3JlU3RhdGUoKTtcbiAgfVxuXG59O1xuXG5jb25zdCBzdGF0aWNQcm9wZXJ0aWVzID0ge1xuICBjb250ZXh0VHlwZXM6IHtcbiAgICBmbHV4OiBQcm9wVHlwZXMuaW5zdGFuY2VPZihGbHV4KSxcbiAgfSxcblxuICBjaGlsZENvbnRleHRUeXBlczoge1xuICAgIGZsdXg6IFByb3BUeXBlcy5pbnN0YW5jZU9mKEZsdXgpLFxuICB9LFxuXG4gIHByb3BUeXBlczoge1xuICAgIGNvbm5lY3RUb1N0b3JlczogUmVhY3QuUHJvcFR5cGVzLm9uZU9mVHlwZShbXG4gICAgICBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgUmVhY3QuUHJvcFR5cGVzLmFycmF5T2YoUmVhY3QuUHJvcFR5cGVzLnN0cmluZyksXG4gICAgICBSZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBdKVxuICB9LFxufTtcblxuZXhwb3J0IHsgaW5zdGFuY2VNZXRob2RzLCBzdGF0aWNQcm9wZXJ0aWVzIH07XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0b3JlTGlzdGVuZXIoY29tcG9uZW50LCBzdG9yZSwgc3RvcmVTdGF0ZUdldHRlcikge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBzdG9yZVN0YXRlR2V0dGVyKHN0b3JlLCB0aGlzLnByb3BzKTtcbiAgICB0aGlzLnNldFN0YXRlKHN0YXRlKTtcbiAgfS5iaW5kKGNvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRTdGF0ZUdldHRlcihzdG9yZSkge1xuICByZXR1cm4gc3RvcmUuc3RhdGU7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRSZWR1Y2VTdGF0ZUdldHRlcihzdG9yZXMpIHtcbiAgcmV0dXJuIHN0b3Jlcy5yZWR1Y2UoXG4gICAgKHJlc3VsdCwgc3RvcmUpID0+IGFzc2lnbihyZXN1bHQsIHN0b3JlLnN0YXRlKSxcbiAgICB7fVxuICApO1xufVxuIl19