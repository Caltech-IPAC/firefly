package edu.caltech.ipac.client;

import edu.caltech.ipac.util.Assert;
import edu.caltech.ipac.util.ComparisonUtil;

import java.beans.PropertyChangeListener;
import java.beans.VetoableChangeListener;
import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.List;
/**
 * User: roby
 * Date: Dec 19, 2007
 * Time: 10:28:03 AM
 */


/**
 * @author Trey Roby
 */
public class ClientEventManager {



    private static transient List<EvListenerContainer> _evListeners=
                                  new ArrayList<EvListenerContainer>(30);
    private static transient List<EvListenerContainer> _vetoEvListeners=
                                  new ArrayList<EvListenerContainer>(10);

    private static transient List<PCListenerContainer> _pcListeners =
                                  new ArrayList<PCListenerContainer>(30);
    private static transient List<PCListenerContainer> _vetoPCListeners =
                                  new ArrayList<PCListenerContainer>(10);

//======================================================================
//----------------------- Constructors ---------------------------------
//======================================================================

//======================================================================
//----------------------- Public Methods -------------------------------
//======================================================================


    /**
     * Add a ClientEventListener. Warning! this is a weak reference.
     * If you are not pointing at it then the listener will be garbage collected!
     * This methods adds events for all sources and names
     * @param l the listener
     */
    public static void addWeakClientEventListener(ClientEventListener l) {
        addWeakClientEventListener(l,null,null);
    }
    /**
     * Add a ClientEventListener. Warning! this is a weak reference.
     * If you are not pointing at it then the listener will be garbage collected!
     * This methods adds events for all sources
     * @param l the listener
     * @param eventName limit the event name to only this event, null means all events name
     */
    public static void addWeakClientEventListener(ClientEventListener l,
                                                  EventName eventName) {
        addWeakClientEventListener(l,eventName,null);
    }
    /**
     * Add a ClientEventListener. Warning! this is a weak reference.
     * If you are not pointing at it then the listener will be garbage collected!
     * @param l the listener
     * @param eventName limit the event name to only this event, null means all events name
     * @param fromSource limit the source to only this source, null means all sources. You may spectify
     *         an instance Object for the source or a Class for the source.  If you specify a class then
     *         all events generated by all instances of that class will be passed
     */
    public static void addWeakClientEventListener(ClientEventListener l,
                                                  EventName eventName,
                                                  Object fromSource) {
        _evListeners.add(new EvListenerContainer(l,eventName, fromSource,true));
    }

    /**
     * Add a VetoableClientEventListener. Warning! this is a weak reference.
     * If you are not pointing at it then the listener will be garbage collected!
     * @param l the listener
     * @param eventName limit the event name to only this event, null means all events name
     * @param fromSource limit the source to only this source, null means all sources. You may spectify
     *         an instance Object for the source or a Class for the source.  If you specify a class then
     *         all events generated by all instances of that class will be passed
     */
    public static void addWeakVetoClientEventListener(VetoableClientEventListener l,
                                                      EventName eventName,
                                                      Object fromSource) {
        _vetoEvListeners.add(new EvListenerContainer(l,eventName, fromSource,true));
    }

    /**
     * Add a ClientEventListener.
     * This methods adds events for all sources and names
     * @param l the listener
     */
    public static void addClientEventListener(ClientEventListener l) {
        addClientEventListener(l,null,null);
    }

    /**
     * Add a ClientEventListener.
     * This methods adds events for all sources
     * @param l the listener
     * @param eventName limit the event name to only this event, null means all events name
     */
    public static void addClientEventListener(ClientEventListener l,
                                              EventName eventName) {
        addClientEventListener(l,eventName,null);
    }

    /**
     * Add a VetoableClientEventListener.
     * @param l the listener
     * @param eventName limit the event name to only this event, null means all events name
     * @param fromSource limit the source to only this source, null means all sources. You may spectify
     *         an instance Object for the source or a Class for the source.  If you specify a class then
     *         all events generated by all instances of that class will be passed
     */
    public static void addClientEventListener(ClientEventListener l,
                                                  EventName eventName,
                                                  Object fromSource) {
        _evListeners.add(new EvListenerContainer(l,eventName, fromSource,false));
    }


    /**
     * Add a ClientEventListener.
     * @param l the listener
     * @param eventName limit the event name to only this event, null means all events name
     */
    public static void addVetoClientEventListener(VetoableClientEventListener l,
                                                  EventName eventName) {
        _vetoEvListeners.add(new EvListenerContainer(l,eventName, null,false));
    }



    /**
     * Add a ClientEventListener.
     * @param l the listener
     * @param eventName limit the event name to only this event, null means all events name
     * @param fromSource limit the source to only this source, null means all sources. You may spectify
     *         an instance Object for the source or a Class for the source.  If you specify a class then
     *         all events generated by all instances of that class will be passed
     */
    public static void addVetoClientEventListener(VetoableClientEventListener l,
                                              EventName eventName,
                                              Object fromSource) {
        _vetoEvListeners.add(new EvListenerContainer(l,eventName, fromSource,false));
    }




    public static void removeClientEventListener(ClientEventListener l) {
        removeClientEventListener(l,null,null);
    }

    public static void removeClientEventListener(ClientEventListener l, EventName eventName) {
        removeClientEventListener(l,eventName,null);
    }
    public static void removeClientEventListener(ClientEventListener l,
                                                 EventName eventName,
                                                 Object fromSource) {
        EvListenerContainer lc= findEvListener(l,eventName,fromSource);
        _evListeners.remove(lc);
    }

    public static void removeVetoClientEventListener(VetoableClientEventListener l,
                                                     EventName eventName) {
        EvListenerContainer lc= findVetoEvListener(l,eventName,null);
        _vetoEvListeners.remove(lc);
    }

    public static void removeVetoClientEventListener(VetoableClientEventListener l,
                                                     EventName eventName,
                                                     Object fromSource) {
        EvListenerContainer lc= findVetoEvListener(l,eventName,fromSource);
        _vetoEvListeners.remove(lc);
    }

//    public static void firePropertyChangeEvent(Object source,
//                                        String propName,
//                                        Object oldValue,
//                                        Object newValue) {
//        firePropertyChangeEvent(
//                  new PropertyChangeEvent(source,propName,oldValue,newValue));
//    }
//
//
//    public static void firePropertyChangeEvent(PropertyChangeEvent ev) {
//        List<EvListenerContainer> newlist;
//
//        ClientEventListener listener;
//        synchronized (ClientEventManager.class) {
//            newlist = new ArrayList<EvListenerContainer>(_evListeners);
//        }
//
//        List<EvListenerContainer> toDel= new ArrayList<EvListenerContainer>(2);
//        boolean fireBySource;
//        boolean fireByName;
//        if (!ComparisonUtil.equals(ev.getOldValue(),ev.getNewValue())) {
//            for(EvListenerContainer lc : newlist)  {
//                listener = lc.getListener();
//                if (listener!=null) {
//                    fireBySource= (lc.getSource()==null || ev.getSource()==lc.getSource());
//                    fireByName= (lc.getEventName()==null ||
//                                 ComparisonUtil.equals(ev.getPropertyName(),lc.getEventName()));
//                    if (fireBySource && fireByName) {
//                        listener.propertyChange(ev);
//                    }
//                }
//                else {
//                    toDel.add(lc);
//                }
//            }
//            for(EvListenerContainer lc : toDel) _evListeners.remove(lc);
//        }
//    }
//
//
//    public static void fireVetoPropertyChangeEvent(Object source,
//                                               String propName,
//                                               Object oldValue,
//                                               Object newValue) throws VetoClientEventException {
//        fireVetoPropertyChangeEvent(
//                          new PropertyChangeEvent(source,propName,oldValue,newValue));
//    }
//
//
//    public static void fireVetoPropertyChangeEvent(PropertyChangeEvent ev) throws VetoClientEventException {
//        List<EvListenerContainer> newlist;
//
//        VetoableClientEventListener listener;
//        synchronized (ClientEventManager.class) {
//            newlist = new ArrayList<EvListenerContainer>(_vetoEvListeners);
//        }
//
//        List<EvListenerContainer> toDel= new ArrayList<EvListenerContainer>(2);
//        boolean fireBySource;
//        boolean fireByName;
//        if (!ComparisonUtil.equals(ev.getOldValue(),ev.getNewValue())) {
//            for(EvListenerContainer lc : newlist)  {
//                listener = lc.getVetoListener();
//                if (listener!=null) {
//                    fireBySource= (lc.getSource()==null || ev.getSource()==lc.getSource());
//                    fireByName= (lc.getEventName()==null ||
//                                 ComparisonUtil.equals(ev.getPropertyName(),lc.getEventName()));
//                    if (fireBySource && fireByName) {
//                        listener.vetoablePropertyChange(ev);
//                    }
//                }
//                else {
//                    toDel.add(lc);
//                }
//            }
//            for(EvListenerContainer lc : toDel) _vetoEvListeners.remove(lc);
//        }
//    }





    /**
     * Fire an event
     * @param ev the event to fire
     */
    public static void fireClientEvent(ClientEvent ev) {
        List<EvListenerContainer> newlist;

        ClientEventListener listener;
        synchronized (ClientEventManager.class) {
            newlist = new ArrayList<EvListenerContainer>(_evListeners);
        }

        List<EvListenerContainer> toDel= new ArrayList<EvListenerContainer>(2);
        boolean fireBySource;
        boolean fireByName;
        for(EvListenerContainer lc : newlist)  {
            listener = lc.getListener();
            if (listener!=null) {
                fireBySource= (lc.getSource()==null ||
                               ev.getSource()==lc.getSource() ||
                               ev.getSource().getClass() == lc.getSource());
                fireByName= (lc.getEventName()==null ||
                             ComparisonUtil.equals(ev.getName(),lc.getEventName()));
                if (fireBySource && fireByName) {
                        listener.eventNotify(ev);
                }
            }
            else {
                toDel.add(lc);
            }
        }
        for(EvListenerContainer lc : toDel) _evListeners.remove(lc);
    }


    /**
     * Fire an event
     * @param ev the event to fire
     * @throws VetoClientEventException if this event is vetoed by a listener
     */
    public static void fireVetoableClientEvent(ClientEvent ev) throws VetoClientEventException {
        List<EvListenerContainer> newlist;

        VetoableClientEventListener listener;
        synchronized (ClientEventManager.class) {
            newlist = new ArrayList<EvListenerContainer>(_vetoEvListeners);
        }

        List<EvListenerContainer> toDel= new ArrayList<EvListenerContainer>(2);
        boolean fireBySource;
        boolean fireByName;
        for(EvListenerContainer lc : newlist)  {
            listener = lc.getVetoListener();
            if (listener!=null) {
                fireBySource= (lc.getSource()==null ||
                               ev.getSource()==lc.getSource() ||
                               ev.getSource().getClass() == lc.getSource());
                fireByName= (lc.getEventName()==null ||
                             ComparisonUtil.equals(ev.getName(),lc.getEventName()));
                if (fireBySource && fireByName) {
                    listener.vetoableEventNotify(ev);
                }
            }
            else {
                toDel.add(lc);
            }
        }
        for(EvListenerContainer lc : toDel) _vetoEvListeners.remove(lc);
    }






//=======================================================================
//-------------- Method from LabelSource Interface ----------------------
//=======================================================================

//======================================================================
//------------------ Private / Protected Methods -----------------------
//======================================================================

    private static EvListenerContainer findEvListener(ClientEventListener listener,
                                                      EventName eventName,
                                                      Object fromSource) {
        EvListenerContainer retval= null;

        if (listener!=null) {
            for(EvListenerContainer lc : _evListeners) {
                if (listener==lc.getListener() &&
                    ComparisonUtil.equals(eventName,lc.getEventName()) &&
                    fromSource==lc.getSource() ) {
                    retval= lc;
                    break;
                }
            }
        }
        return retval;
    }

    private static EvListenerContainer findVetoEvListener(VetoableClientEventListener listener,
                                                          EventName eventName,
                                                          Object fromSource) {
        EvListenerContainer retval= null;

        if (listener!=null) {
            for(EvListenerContainer lc : _vetoEvListeners) {
                if (listener==lc.getVetoListener() &&
                    ComparisonUtil.equals(eventName,lc.getEventName()) &&
                    fromSource==lc.getSource() ) {
                    retval= lc;
                    break;
                }
            }
        }
        return retval;
    }



    private static PCListenerContainer findPCListener(PropertyChangeListener listener,
                                                      String propName,
                                                      Object fromSource) {
        PCListenerContainer retval= null;

        if (listener!=null) {
            for(PCListenerContainer lc : _pcListeners) {
                if (listener==lc.getListener() &&
                    ComparisonUtil.equals(propName,lc.getPropName()) &&
                    fromSource==lc.getSource() ) {
                    retval= lc;
                    break;
                }
            }
        }
        return retval;
    }


    private static PCListenerContainer findVetoPCListener(PropertyChangeListener listener,
                                                      String propName,
                                                      Object fromSource) {
        PCListenerContainer retval= null;

        if (listener!=null) {
            for(PCListenerContainer lc : _vetoPCListeners) {
                if (listener==lc.getListener() &&
                    ComparisonUtil.equals(propName,lc.getPropName()) &&
                    fromSource==lc.getSource() ) {
                    retval= lc;
                    break;
                }
            }
        }
        return retval;
    }


// =====================================================================
// -------------------- Static Inner Classes ---------------------------
// =====================================================================

    private static class EvListenerContainer {
        private final Object _source;
        private final Object _listener;
        private final EventName  _eventName;
        private final boolean _veto;

        public EvListenerContainer(ClientEventListener listener,
                                  EventName eventName,
                                  Object source,
                                  boolean weak) {
            _eventName= eventName;
            _source= source;
            _veto= false;
            _listener= weak ?
                       new WeakReference<ClientEventListener>(listener) :
                       listener;

        }

        public EvListenerContainer(VetoableClientEventListener listener,
                                  EventName eventName,
                                  Object source,
                                  boolean weak) {
            _eventName= eventName;
            _source= source;
            _veto= true;
            _listener= weak ?
                       new WeakReference<VetoableClientEventListener>(listener) :
                       listener;
        }

        public ClientEventListener getListener() {

            Assert.argTst(!_veto, "This container is set up with a ClientEventListener not a VetoableClientEventListener");
            ClientEventListener retval= null;
            if (_listener instanceof ClientEventListener) {
                retval= (ClientEventListener)_listener;
            }
            else if (_listener instanceof WeakReference) {
                retval= ((WeakReference<ClientEventListener>)_listener).get();
            }
            return retval;
        }

        public VetoableClientEventListener getVetoListener() {
            Assert.argTst(_veto, "This container is set up with a VetoableClientEventListener not a ClientEventListener");
            VetoableClientEventListener retval= null;
            if (_listener instanceof VetoableClientEventListener) {
                retval= (VetoableClientEventListener)_listener;
            }
            else if (_listener instanceof WeakReference) {
                retval= ((WeakReference<VetoableClientEventListener>)_listener).get();
            }
            return retval;
        }

        public EventName getEventName() {  return _eventName; }
        public Object getSource() {  return _source; }
        public boolean isVeto() { return _veto; }
    }



    private static class PCListenerContainer {
        private final Object _source;
        private final Object _listener;
        private final String _propName;
        private final boolean _veto;

        public PCListenerContainer(PropertyChangeListener listener,
                                   String propName,
                                   Object source,
                                   boolean weak) {
            _propName= propName;
            _source= source;
            _veto= false;
            _listener= weak ?
                       new WeakReference<PropertyChangeListener>(listener) :
                       listener;

        }

        public PCListenerContainer(VetoableChangeListener listener,
                                   String propName,
                                   Object source,
                                   boolean weak) {
            _propName= propName;
            _source= source;
            _veto= true;
            _listener= weak ?
                       new WeakReference<VetoableChangeListener>(listener) :
                       listener;
        }

        public PropertyChangeListener getListener() {

            Assert.argTst(!_veto, "This container is set up with a ClientEventListener not a VetoableClientEventListener");
            PropertyChangeListener retval= null;
            if (_listener instanceof PropertyChangeListener) {
                retval= (PropertyChangeListener)_listener;
            }
            else if (_listener instanceof WeakReference) {
                retval= ((WeakReference<PropertyChangeListener>)_listener).get();
            }
            return retval;
        }

        public VetoableChangeListener getVetoListener() {
            Assert.argTst(_veto, "This container is set up with a VetoableClientEventListener not a ClientEventListener");
            VetoableChangeListener retval= null;
            if (_listener instanceof VetoableChangeListener) {
                retval= (VetoableChangeListener)_listener;
            }
            else if (_listener instanceof WeakReference) {
                retval= ((WeakReference<VetoableChangeListener>)_listener).get();
            }
            return retval;
        }

        public String getPropName() {  return _propName; }
        public Object getSource() {  return _source; }
        public boolean isVeto() { return _veto; }
    }




}

/*
 * THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE CALIFORNIA 
 * INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S. GOVERNMENT CONTRACT WITH 
 * THE NATIONAL AERONAUTICS AND SPACE ADMINISTRATION (NASA). THE SOFTWARE 
 * IS TECHNOLOGY AND SOFTWARE PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS 
 * AND IS PROVIDED AS-IS TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, 
 * INCLUDING ANY WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR 
 * A PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC 2312- 2313) 
 * OR FOR ANY PURPOSE WHATSOEVER, FOR THE SOFTWARE AND RELATED MATERIALS, 
 * HOWEVER USED.
 * 
 * IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY, OR NASA BE LIABLE 
 * FOR ANY DAMAGES AND/OR COSTS, INCLUDING, BUT NOT LIMITED TO, INCIDENTAL 
 * OR CONSEQUENTIAL DAMAGES OF ANY KIND, INCLUDING ECONOMIC DAMAGE OR INJURY TO 
 * PROPERTY AND LOST PROFITS, REGARDLESS OF WHETHER CALTECH, JPL, OR NASA BE 
 * ADVISED, HAVE REASON TO KNOW, OR, IN FACT, SHALL KNOW OF THE POSSIBILITY.
 * 
 * RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE OF THE SOFTWARE 
 * AND ANY RELATED MATERIALS, AND AGREES TO INDEMNIFY CALTECH AND NASA FOR 
 * ALL THIRD-PARTY CLAIMS RESULTING FROM THE ACTIONS OF RECIPIENT IN THE USE 
 * OF THE SOFTWARE. 
 */
